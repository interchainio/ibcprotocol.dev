(window.webpackJsonp=window.webpackJsonp||[]).push([[18,9],{278:function(e,t,n){var content=n(280);content.__esModule&&(content=content.default),"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,n(26).default)("0764daec",content,!0,{sourceMap:!1})},279:function(e,t,n){"use strict";n(278)},280:function(e,t,n){var r=n(25)(!1);r.push([e.i,".title-line[data-v-69eeb4df]{width:90px;height:1px}",""]),e.exports=r},282:function(e,t,n){"use strict";n.r(t);n(193);var r={props:{index:{type:Number,default:0}},computed:{classes:function(){return this.$props.index%4==0||this.$props.index%4==3?"bg-gradientRed":(this.$props.index,"bg-gradientPurple")}}},l=(n(279),n(9)),component=Object(l.a)(r,(function(){var e=this,t=e.$createElement;return(e._self._c||t)("div",{staticClass:"title-line mb-4",class:e.classes})}),[],!1,null,"69eeb4df",null);t.default=component.exports},329:function(e,t,n){"use strict";n.r(t);var r=n(7),l=(n(39),{components:{TitleLine:n(282).default},asyncData:function(e){return Object(r.a)(regeneratorRuntime.mark((function t(){var n,r;return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return n=e.$content,t.next=3,n("implementations/relayers").fetch();case 3:return r=t.sent,t.abrupt("return",{page:r});case 5:case"end":return t.stop()}}),t)})))()}}),c=n(9),component=Object(c.a)(l,(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"max-w-6xl mx-auto px-4 md:px-8"},[n("div",{staticClass:"flex flex-col my-16 md:flex-row"}),e._v(" "),n("div",{staticClass:"-mt-16 md:-mt-32"},[n("h3",{staticClass:"heading-sm mb-6"},[e._v("Relayers")]),e._v("\n    In the IBC architecture, blockchains are not directly sending messages to\n    each other over networking infrastructure, but rather are creating\n    messages to be sent which are then physically relayed from one ledger to\n    another by monitoring “relayer processes”. IBC assumes the existence of a\n    set of relayers with access to an underlying network protocol stack\n    (likely TCP/IP, UDP/IP, or QUIC/IP) and physical interconnect\n    infrastructure. These relayers continuously scan the state of ledgers that\n    implement the IBC protocol and relay packets when these packets are\n    present. This enables transaction execution on connected ledgers when\n    outgoing packets relayed over have been committed. Relayers CANNOT modify\n    IBC packets, as each IBC packet is verified using light-clients by the\n    receiving chain before being committed. Running relayers is open to\n    everyone, and may be rewarded with a small transaction fee depending on\n    the implementation of each ledger. The following relayer implementations\n    are available for usage:\n    "),n("div",{staticClass:"flex flex-col my-5 md:flex-row"}),e._v(" "),n("div",{staticClass:"flex flex-wrap"},e._l(e.page.public,(function(t,r){return n("div",{key:t.slug,staticClass:"w-full md:w-1/2 pr-0 md:pr-16 mb-12 md:mb-0",class:{"opacity-25":null===t.value}},[n("Title-Line",{attrs:{index:r}}),e._v(" "),n("a",{staticClass:"relative flex w-full justify-between",attrs:{href:t.link,target:"_blank"}},[n("h2",{staticClass:"text-lg md:text-2xl mb-3"},[e._v(e._s(t.title))])]),e._v(" "),t.description?n("p",[e._v(e._s(t.description))]):e._e(),e._v(" "),n("br"),e._v(" "),n("br")],1)})),0)])])}),[],!1,null,null,null);t.default=component.exports}}]);